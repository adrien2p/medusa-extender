# Full code API :mag:

If you want to access to the code documentation generated by typedoc you can follow that [link](https://adrien2p.github.io/medusa-extender/#/modules)

# API documentation :bulb:

Here, We will see the different tools that the extender provides you
in order to allow you to customise your medusa api according to your needs.

## Decorators

Lets start with the decorators. They are the main API you will use in your project.
Let see each of the decorators that are available and what are there purpose.

:closed_book: __Here is a summary of whats coming in the following sections:__

{{ decoratorApiSummary }}

### @Entity

This decorator gives you the ability to either create a new entity that will
then be handled by medusa or, to override an existing entity in order to add some custom
fields or other stuff in it.

:point_right: __Create a new entity__

In some cases, you will need to create new entity in order to represent a custom
data model that correspond to a specific need of yours.

Let see an example
    
```typescript
import { Column, Entity } from "typeorm"; 
import { Entity as MedusaEntity } from "medusa-extender";

@MedusaEntity()
@Entity()
export class MyCustomEntity {
    @Column()
    name: string;
}
```

> `@MedusaEntity` decorator will only be used by medusa in order to store
> that entity into the container. The stored entity will then be added to typeorm.

:point_right: __Override an existing entity__

There is other cases where you will need to extends an existing entity provided by medusa.
In those cases, medusa does not provides a way to do that (not event typeorm).

For example, you would like to add a new field to the product entity in order to store
the `store_id`.

Let see an example
    
```typescript
import { Column, Entity } from "typeorm"; 
import { Product as MedusaProduct } from '@medusa/medusa/dist';
import { Entity as MedusaEntity } from "medusa-extender";

@MedusaEntity({ override: MedusaProduct })
@Entity()
export class Product extends MedusaProduct {
    @Column()
    customField: string;
}
```

> The `override` parameter of the `@MedusaEntity` decorator allow to specify which entity
> from the core must be overridden.

To make your project aware of your customisation 
at the medusa core level, you can use the [module augmentation](https://www.typescriptlang.org/docs/handbook/declaration-merging.html)
approach.

here is an example

```ts
// src/modules/your_modules/index.d.ts

import { User as ExtendedUser } from '@modules/user/user.entity';
import { default as ExtendedUserRepository } from '@modules/user/user.repository';

declare module '@medusajs/medusa/dist/models/user' {
  export declare class User extends ExtendedUser {}
}

declare module '@medusajs/medusa' {
  export declare class UserRepository extends ExtendedUserRepository {}
}

```

To see a live example, you can look at the starters, they include the module augmentation approach.

### @Repository

This decorator gives you the ability to either create a new custom repository that will
then be handled by medusa or, to override an existing custom repository in case you've overridden
and existing entity as seen in the previous section.

:point_right: __Create a new custom repository__

In some cases, you will need to create new custom repository in order to interact with your custom entity
and being able to add some custom logic related to that entity.

Let see an example

```typescript
import { Repository as MedusaRepository } from "medusa-extender";
import { EntityRepository, Repository } from "typeorm";
import { MyCustomEntity } from "./custom.entity";

@MedusaRepository()
@EntityRepository(MyCustomEntity)
export default class MyCustomRepository extends Repository<MyCustomEntity> {}
```

> `@MedusaRepository` decorator will only be used by medusa in order to store
> that custom repository into the container. The stored repository will be accessible through the dependency
> injection in any of your services. You can also access the container to resolve
> a dependency in your routes handler through `req.scope.resolve('myCustomRepository')`.

:point_right: __Override an existing custom repository__

There is other cases where you will need to extends an existing custom repository provided by medusa in
order to reflect the changes you've made with the custom entity. Also, it will
allow you to extends custom logic that could have been implemented in the custom repository
by the medusa core.

To follow the previous example, we need to create a custom repository that extends
the one provided by medusa to manage our extended entity created in the previous section.

Let see an example
    
```typescript
import { ProductRepository as MedusaProductRepository } from "@medusajs/medusa/dist/repositories/product";
import { Repository as MedusaRepository, Utils } from "medusa-extender";
import { EntityRepository } from "typeorm";
import { Product } from "./product.entity";

@MedusaRepository({ override: MedusaProductRepository })
@EntityRepository(Product)
export default class UserRepository extends Utils.repositoryMixin<Product, MedusaProductRepository>(MedusaProductRepository) {}
```

> The `override` parameter of the `@MedusaRepository` decorator allow to specify which custom repository
> from the core must be overridden. You can also access the container to resolve
> a dependency in your routes handler through `req.scope.resolve('key')`.

> The `Utils.repositoryMixin` is a special utility exported by the extender that
> allow multiple class inheritance. This is mandatory to be able to extend an existing
> custom repository.

### @Migration

This decorator allow you to apply new migrations. That can be used to update
an existing entity that you've extended or a new entity that you've created.
The migration is manage by typeorm and work as usual.

Let see an example

```typescript
import { MigrationInterface, QueryRunner } from 'typeorm';
import { Migration } from 'medusa-extender';

@Migration()
export default class addCustomFieldToProduct1611063162649 implements MigrationInterface {
    public async up(queryRunner: QueryRunner): Promise<void> {
        const query = `ALTER TABLE public."product"
            ADD COLUMN IF NOT EXISTS "customField" text;`;
        await queryRunner.query(query);
    }
    
    public async down(queryRunner: QueryRunner): Promise<void> {
        const query = `ALTER TABLE public."product"
            DROP COLUMN "customField";`;
        await queryRunner.query(query);
    }
}
``` 

### @Service

This decorator gives you the ability to either create a new service that will
then be handled by medusa or, to override an existing service in case you need to add extra logic
or to override existing logic to solve one of your problem.

:point_right: __Create a new service__

If you are currently adding a new feature on top of medusa or extending an existing feature
that require to split the logic into another service, here is how you can achieve that.

Let see an example

```typescript
import { Service } from 'medusa-extender';
import { EntityManager } from 'typeorm';

type ConstructorParams = {
    manager: EntityManager;
};

@Service()
export default class MyCustomService {
    static resolutionKey = 'myCustomService';
 
    private readonly manager: EntityManager;
    
    constructor({ manager }: ConstructorParams) {
        this.manager = manager;
    }
}
```

> `@Service` decorator will only be used by medusa in order to store
> that service into the container. The stored service will be accessible through the dependency
> injection in any of your other services. You can also access the container to resolve
> a dependency in your routes handler through `req.scope.resolve('myCustomService')`.

The `@Service` decorator also accept a `scope` property that is of type `LifetimeType`.
The scope will be used by the container to manage that resource.

:point_right: __Scoped service__

In some cases, you'll maybe have register new resources to the container through a middleware.
Since those resources are registered during the request handling, it is only available
for newly created resources. The resources that use the `scope` with the value `scoped` are
re created for each new request.

Let's imagine that one of your middleware register the `loggedInUser` into the container
when a request hit a protected end point. If you need to be able to access that `loggedInUser`,
your service must be scoped in order to get a fresh cradle where your resources will be accessible.

Let see an example

```typescript
import { Service } from 'medusa-extender';
import { EntityManager } from 'typeorm';
import { User } from '../user/user.entity';

type ConstructorParams = {
    loggedInUser: User;
    manager: EntityManager;
};

@Service({ scope: 'SCOPED' })
export default class MyCustomService {
    static resolutionKey = 'myCustomService';

    private readonly manager: EntityManager;
    
    constructor(private readonly container: ConstructorParams) {
        super();
        this.manager = container.manager;
    }
    
    public customMethod(): void {
        const loggedInUser = this.container.loggedInUser;
        console.log(loggedInUser);
    }
}
```

As you can see, we've added the `loggedInUser` to the `ConstructorParams`type and
we are getting the `loggedInUser` through the container in the `customMethod` for a later
usage.

:point_right: __Override an existing service__

In some other case, you will need to override an existing service to either be able
to add new functionalities or to add new logic using existing code blocks.

Let see an example
    
```typescript
import { EntityEventType, MedusaEventHandlerParams, OnMedusaEntityEvent, Service } from 'medusa-extender';
import { ProductService as MedusaProductService } from '@medusajs/medusa/dist/services';
import { EntityManager } from 'typeorm';
import EventBusService from '@medusajs/medusa/dist/services/event-bus';
import { ProductVariantRepository } from '@medusajs/medusa/dist/repositories/product-variant';
import { ProductOptionRepository } from '@medusajs/medusa/dist/repositories/product-option';
import ProductVariantService from '@medusajs/medusa/dist/services/product-variant';
import ProductCollectionService from '@medusajs/medusa/dist/services/product-collection';
import { ProductTypeRepository } from '@medusajs/medusa/dist/repositories/product-type';
import { ProductTagRepository } from '@medusajs/medusa/dist/repositories/product-tag';
import { ImageRepository } from '@medusajs/medusa/dist/repositories/image';
import DefaultSearchService from '@medusajs/medusa/dist/services/search';
import ProductRepository from './product.repository';
import { Product } from './product.entity';
import { User } from '../user/user.entity';
import { FindConfig } from '@medusajs/medusa/dist/types/common';

interface ConstructorParams<TSearchService extends DefaultSearchService = DefaultSearchService> {
    loggedInUser: User;
    manager: EntityManager;
    productRepository: typeof ProductRepository;
    productVariantRepository: typeof ProductVariantRepository;
    productOptionRepository: typeof ProductOptionRepository;
    eventBusService: EventBusService;
    productVariantService: ProductVariantService;
    productCollectionService: ProductCollectionService;
    productTypeRepository: typeof ProductTypeRepository;
    productTagRepository: typeof ProductTagRepository;
    imageRepository: typeof ImageRepository;
    searchService: TSearchService;
}

@Service({ override: MedusaProductService, scope: 'SCOPED' })
export default class ProductService extends MedusaProductService {
    private readonly manager: EntityManager;
    
    constructor(private readonly container: ConstructorParams) {
        super(container);
        this.manager = container.manager;
    }
    
    @OnMedusaEntityEvent.Before.Insert(Product, { async: true })
    public async attachStoreToProduct(
        params: MedusaEventHandlerParams<Product, 'Insert'>
    ): Promise<EntityEventType<Product, 'Insert'>> {
        const loggedInUser = this.container.loggedInUser;
        const { event } = params;
        event.entity.store_id = loggedInUser.store_id;
        event.entity.handle = loggedInUser.store_id.replace('store_', '') + '-' + event.entity.handle;
        return event;
    }

    public prepareListQuery_(selector: Record<string, any>, config: FindConfig<Product>): object {
        if (Object.keys(this.container).includes('loggedInUser')) {
            selector['store_id'] = this.container.loggedInUser.store_id;
        }
        return super.prepareListQuery_(selector, config);
    }
}
```

> The `override` parameter of the `@ProductService` decorator allow to specify which service
> from the core must be overridden.

> As we've seen in the previous section, the `scope` value allow you to specify the 
> behaviour of the resource that is managed by the container. In that case, the service will
> be re created for each new request in order for you to access the `loggedInUser` as we've seen
> in the previous section.

> :warning: You should have the less possible resources using the `scoped` lifetime
> to avoid lower performance, it must be used in special cases such as being able to access
> specific values that does exists only during the request processing. :warning:

### @Middleware

The middleware decorator allow you to create new middleware on specific routes
that can be handled before the authentication or after the authentication but always before
your handler.

In this example, we will see how to get and store the `loggedInUser` into the container
through a new middleware (as we've used in the previous section).

Let see an example

```typescript
import { MedusaAuthenticatedRequest, MedusaMiddleware, Middleware } from 'medusa-extender';
import { NextFunction, Response } from 'express';

import UserService from './user.service';

@Middleware({ requireAuth: true, routes: [{ method: "all", path: '*' }] })
export class LoggedInUserMiddleware implements MedusaMiddleware {
    public async consume(req: MedusaAuthenticatedRequest, res: Response, next: NextFunction): Promise<void> {
        if (req.user && req.user.userId) {
            const userService = req.scope.resolve('userService') as UserService;
            const loggedInUser = await userService.retrieve(req.user.userId, {
                select: ['id', 'your_custom_field'],
            });
            
            req.scope.register({
                loggedInUser: {
                    resolve: () => loggedInUser,
                },
            });
        }
        next();
    }
}
```

In this scenario, the middleware is applied after the medusa authentication strategy.
We need to be after the authentication to be able to be sure that the user is already
authenticated and that we have access to the `userId`.

This middleware is applied to all routes and will retrieve the authenticated user
to store it in the underlying container. You will be then be able to get access to it
into your servives as we've seen in the previous sections.

### @Router

This decorator allow you to create new custom routes in your application.

Let see an example

```typescript
import { Router } from 'medusa-extender';
import myCustomController from './myCustomController.controller';

@Router({
    routes: [
        {
            requiredAuth: true,
            path: '/admin/custom-route/',
            method: 'get',
            handlers: [myCustomController.handleCustomroute],
        },
    ],
})
export class DashboardRouter {}
```

In that example, we are attaching a new route on the admin, `/admin/custom-route/`.
This route will be handle by the custom controller. The custom controller is just 
a class that provide some methods. The file export an instance of that class (which is not decorated).

In that particular case, to be able to access the route, the user need to be authenticated.

### @Validator

In some cases, when you override a service to extends its logic 
because you've added a custom field to an existing entity, you might
encounter an error. When you use an existing route handling an entity that
has been extended, medusa is not aware about that, and therefor the underlying validators
does not take that in count.

To fix that problem, you can extend the underlying validator to add the constraint on your custom
field and make medusa aware about it.

let see an example


```typescript
import { Validator } from 'medusa-extender';
import { AdminPostProductsReq } from '@medusajs/medusa/dist/api/routes/admin/products/create-product'
import { IsString } from 'class-validator';

@Validator({ override: AdminPostProductsReq })
class ExtendedClassValidator extends AdminPostProductsReq {
  @IsString()
  customField: string;
}
```

In that example, we imagine that you add a custom field on the product entity.
But without doing anything else, medusa will handle it through the underlying
handler for the creation but will now be aware of that field and therefor
will take care of saving it. Otherwise, you will end up with an error thrown by the
validator to tell you that this fields is not recognised.

### @Subscriber

Allow you to register new subscriber. The subscribers are built through the container
but not registered as part of the container.

let see an example


```typescript
import { Subscriber } from 'medusa-extender';
import { ProductService, EventBusService } from "@medusajs/medusa/dist/services";

@Subscriber()
class OrderSubscriber {
    private readonly eventBusService: EventBusService;

    constructor({ eventBusService }: { eventBusService: EventBusService }) {
        this.eventBusService = eventBusService;
        this.eventBusService.subscribe(
          ProductService.Events.CREATED,
          this.handleProductCreation
        );
    }
    
    private async handleProductCreation(): Promise<void> {
        console.log('I have been called after a product has been placed.')
    }
}
```

### @Module

This decorator allow to aggregate any modules and components in one place to simplify the usage
by the medusa-extender loader and allows you to simplify you exports and organise your features by group.

Let see an example

```typescript
import { Module } from 'medusa-extender';
import { Product } from './product.entity';
import ProductRepository from './product.repository';
import ProductService from './product.service';

@Module({
    imports: [
        Product,
        ProductRepository,
        ProductService
    ],
})
export class ProductModule {}
```

Then this module can be imported into the main file as the following example

```typescript
import express = require('express');
const config = require('../medusa-config');
import { Medusa } from 'medusa-extender';
import { resolve } from 'path';
import { ProductModule } from './modules/product/product.module';

async function bootstrap() {
    const expressInstance = express();
    
    const rootDir = resolve(__dirname, '..');
    await new Medusa(rootDir, expressInstance).load([
        ProductModule
    ]);
    
    expressInstance.listen(config.serverConfig.port, () => {
        console.log('Server listening on port ' + config.serverConfig.port);
    });
}
bootstrap();
```

### @Module (Dynamic module)

It is also possible to create dynamic modules that enable to register component dynamically depending on some config 
or external call api for example. 

Let see an example

```typescript
import { Module } from 'medusa-extender';
import { Product } from './product.entity';
import ProductRepository from './product.repository';
import ProductService from './product.service'; 
import { MedusaDynamicModule,ModuleInjectionOptions } from "./types";

@Module(~~~~)
export class ProductModule implements MedusaDynamicModule {
    async forRoot(configModule: Record<string, unknown>): Promise<ModuleInjectionOptions> {
        return { 
            imports: [
                Product,
                ProductRepository,
                ProductService
            ]
        };
    }
}
```

Then this module can be imported into the main file as the following example

```typescript
import express = require('express');
const config = require('../medusa-config');
import { Medusa } from 'medusa-extender';
import { resolve } from 'path';
import { ProductModule } from './modules/product/product.module';

async function bootstrap() {
    const expressInstance = express();
    
    const rootDir = resolve(__dirname, '..');
    await new Medusa(rootDir, expressInstance).load([
        ProductModule
    ]);
    
    expressInstance.listen(config.serverConfig.port, () => {
        console.log('Server listening on port ' + config.serverConfig.port);
    });
}
bootstrap();
```

### @OnMedusaEntityEvent

This decorator is a special one and work in two ways, it allow to
- Emit a new event from a subscriber
- Listen to an event that has been emitted

Let see an example on how you can emit an event from a subscriber

```typescript
import { Connection, EntitySubscriberInterface, EventSubscriber, InsertEvent } from 'typeorm';
import { eventEmitter, Utils, OnMedusaEntityEvent } from 'medusa-extender';
import { Product } from './product.entity';

@EventSubscriber()
export default class ProductSubscriber implements EntitySubscriberInterface<Product> {
    static attachTo(connection: Connection): void {
        Utils.attachOrReplaceEntitySubscriber(connection, ProductSubscriber);
    }
    
    public listenTo(): typeof Product {
        return Product;
    }
    
    public async beforeInsert(event: InsertEvent<Product>): Promise<InsertEvent<Product>> {
        const eventName = OnMedusaEntityEvent.Before.InsertEvent(User, UserService, 'attachStoreToUser');
        await eventEmitter.emitAsync<InsertEvent<User>>(eventName, {
            event,
            transactionalEntityManager: event.manager,
        });
    }
}
```

Here is how you can register it in medusa.

```typescript
import ProductSubscriber from './product.subscriber';

@Service({ override: MedusaProductService, scope: 'SCOPED' })
export default class ProductService extends MedusaProductService {
  private readonly manager: EntityManager;

  constructor({  manager }: ConstructorParams) {
    super({ manager });
    this.manager = manager;
    ProductSubscriber.attachTo(manager.connection)
  }
}
```

And finally, we will add a new handler to listen to this particular event

```typescript
import ProductSubscriber from './product.subscriber';

@Service({ override: MedusaProductService, scope: 'SCOPED' })
export default class ProductService extends MedusaProductService {
    private readonly manager: EntityManager;
    
    constructor(container: ConstructorParams) {
        super(container);
        this.manager = container.manager;
        // You don't need to register it again if it is registered through a middleware.
        ProductSubscriber.attachTo(this.manager.connection)
    }
    
    /* ... */
    
    @OnMedusaEntityEvent.Before.Insert(Product, { async: true })
    public async attachStoreToProduct(
        params: MedusaEventHandlerParams<Product, 'Insert'>
    ): Promise<EntityEventType<Product, 'Insert'>> {
        const loggedInUser = this.container.loggedInUser;
        const { event } = params;
        event.entity.store_id = loggedInUser.store_id;
        event.entity.handle = loggedInUser.store_id.replace('store_', '') + '-' + event.entity.handle;
        return event;
    }
    
    /* ... */

}
```

Here, we are listening to the product creation, and before the entity is 
inserted into the database, we are retrieving the `loggedInUser` through the container
and attach the `store_id` to the product entity.

## Utilities :wrench:

Here are the utilities that this package provides you.

### attachOrReplaceEntitySubscriber

this utility is used mainly by the subscriber in order to help you attach a new subscriber on the fly with ease.
It will take the `connection` as an argument and manage to remove the previous subscriber and attach the new one if needed.
[See how to use it here](#onmedusaentityevent).

### repositoryMixin

This utility is mandatory when you extend an existing repository.
Since that to be able to work the repository must extend multiple classes in order to reflect the original repository
and the custom extension that you've made. [See how to use it here](#repository).

### Omit

The `Omit` utility allows you to omit a set of properties from a class.
In some cases, extending a class to change the type of a property makes
typescript complains about the typings. In such cases, omitting the parent
property in order to re-create it with your own type in the child class.

> ATTENTION!! This usage must be done carefully to avoid to break things without
> noticing it.

Let see a use case where you want to override the type of an
existing property from the parent class

```typescript
import { Entity, Column } from 'typeorm';
import { Entity as MedusaEntity, Utils } from 'medusa-extender';
import { User as MedusaUser} from '@medusajs/medusa/dist/models';

enum UserRolesExtended {
    BRANCH_STAFF = 0
}

@MedusaEntity({ override: MedusaUser })
@Entity()
export class User extends Utils.Omit(MedusaUser, ['role']) {
    @Column({ 
        nullable: true, 
        enum: UserRolesExtended, 
        default: UserRolesExtended.BRANCH_STAFF}
    )
    role: UserRolesExtended;
}
```